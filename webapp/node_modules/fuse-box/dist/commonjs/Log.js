"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const log = require("fliplog");
const prettysize = require("prettysize");
const prettyTime = require("pretty-time");
class Log {
    constructor(context) {
        this.context = context;
        this.timeStart = process.hrtime();
        this.printLog = true;
        this.totalSize = 0;
        this.printLog = context.doLog;
        log.filter((arg) => {
            if (this.printLog === false)
                return false;
            return null;
        });
    }
    reset() {
        this.timeStart = process.hrtime();
        this.totalSize = 0;
        return this;
    }
    bundleStart(name) {
        log.bold(`${name} ->`).echo();
    }
    printOptions(title, obj) {
        log.bold().yellow(`  → ${title}`).echo();
        for (let i in obj) {
            log.green(`      ${i} : ${obj[i]}`).echo();
        }
    }
    subBundleStart(name, parent) {
        log.bold(`${name} (child of ${parent}) ->`).echo();
    }
    bundleEnd(name, collection) {
        let took = process.hrtime(this.timeStart);
        log
            .ansi()
            .write(`-> Finished`)
            .green(collection.cachedName || collection.name)
            .yellow(`took: ${prettyTime(took, "ms")}`)
            .echo();
    }
    echoHeader(str) {
        log.yellow(` ${str}`).echo();
    }
    echo(str) {
        log.time(true).green(str).echo();
    }
    echoStatus(str) {
        log.title(`→`).cyan(`${str}`).echo();
    }
    echoInfo(str) {
        log.preset('info').green(`  → ${str}`).echo();
    }
    echoBoldRed(msg) {
        log.red().bold(msg).echo();
    }
    echoRed(msg) {
        log.red(msg).echo();
    }
    echoBreak() {
        log.green(`\n  -------------- \n`).echo();
    }
    echoWarning(str) {
        log.yellow(`  → WARNING ${str}`).echo();
    }
    echoYellow(str) {
        log.yellow(str).echo();
    }
    echoGray(str) {
        log.gray(str).echo();
    }
    echoDefaultCollection(collection, contents) {
        if (this.printLog === false)
            return;
        let bytes = Buffer.byteLength(contents, "utf8");
        let size = prettysize(bytes);
        this.totalSize += bytes;
        log
            .ansi()
            .write(`└──`)
            .yellow(` (${collection.dependencies.size} files,  ${size})`)
            .green(collection.cachedName || collection.name)
            .echo();
        collection.dependencies.forEach(file => {
            if (file.info.isRemoteFile)
                return;
            log.title(`     `).dim(`${file.info.fuseBoxPath}`).echo();
        });
    }
    echoCollection(collection, contents) {
        if (this.printLog === false)
            return;
        let bytes = Buffer.byteLength(contents, "utf8");
        let size = prettysize(bytes);
        this.totalSize += bytes;
        log
            .ansi()
            .write(`└──`)
            .green(collection.cachedName || collection.name)
            .yellow(size)
            .write(`(${collection.dependencies.size} files)`)
            .echo();
    }
    end(header) {
        let took = process.hrtime(this.timeStart);
        this.echoBundleStats(header || "Bundle", this.totalSize, took);
    }
    echoBundleStats(header, size, took) {
        const sized = log.chalk().yellow(`Size: ${prettysize(size)}`);
        log.text(`${sized} in ${prettyTime(took, "ms")}`).echo();
    }
}
exports.Log = Log;
