module.exports = { contents: "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar operators_1 = require(\"rxjs/operators\");\nvar muse_1 = require(\"./../muse\");\nfunction zipSamples(eegReadings) {\n    var buffer = [];\n    var lastTimestamp = null;\n    return eegReadings.pipe(operators_1.mergeMap(function (reading) {\n        if (reading.timestamp !== lastTimestamp) {\n            lastTimestamp = reading.timestamp;\n            if (buffer.length) {\n                var result = rxjs_1.from([buffer.slice()]);\n                buffer.splice(0, buffer.length, reading);\n                return result;\n            }\n        }\n        buffer.push(reading);\n        return rxjs_1.from([]);\n    }), operators_1.concat(rxjs_1.from([buffer])), operators_1.mergeMap(function (readings) {\n        var result = readings[0].samples.map(function (x, index) {\n            var data = [NaN, NaN, NaN, NaN, NaN];\n            for (var _i = 0, readings_1 = readings; _i < readings_1.length; _i++) {\n                var reading = readings_1[_i];\n                data[reading.electrode] = reading.samples[index];\n            }\n            return {\n                data: data,\n                index: readings[0].index,\n                timestamp: readings[0].timestamp + index * 1000. / muse_1.EEG_FREQUENCY,\n            };\n        });\n        return rxjs_1.from(result);\n    }));\n}\nexports.zipSamples = zipSamples;\n//# sourceMappingURL=zip-samples.js.map",
dependencies: ["rxjs","rxjs/operators","./../muse"],
sourceMap: "{\"version\":3,\"file\":\"src/lib/zip-samples.js\",\"sourceRoot\":\"\",\"sources\":[\"src/lib/zip-samples.ts\"],\"names\":[],\"mappings\":\";;AAAA,6BAAwC;AACxC,4CAAkD;AAClD,kCAA0C;AAS1C,oBAA2B,WAAmC;IAC1D,IAAM,MAAM,GAAiB,EAAE,CAAC;IAChC,IAAI,aAAa,GAAkB,IAAI,CAAC;IACxC,OAAO,WAAW,CAAC,IAAI,CACnB,oBAAQ,CAA2B,UAAC,OAAO;QACvC,IAAI,OAAO,CAAC,SAAS,KAAK,aAAa,EAAE;YACrC,aAAa,GAAG,OAAO,CAAC,SAAS,CAAC;YAClC,IAAI,MAAM,CAAC,MAAM,EAAE;gBACf,IAAM,MAAM,GAAG,WAAI,CAAC,CAAK,MAAM,SAAE,CAAC,CAAC;gBACnC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;gBACzC,OAAO,MAAM,CAAC;aACjB;SACJ;QACD,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACrB,OAAO,WAAI,CAAC,EAAE,CAAC,CAAC;IACpB,CAAC,CAAC,EACF,kBAAM,CAAC,WAAI,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EACtB,oBAAQ,CAAC,UAAC,QAAsB;QAC5B,IAAM,MAAM,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,UAAC,CAAC,EAAE,KAAK;YAC5C,IAAM,IAAI,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;YACvC,KAAsB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ;gBAAzB,IAAM,OAAO,iBAAA;gBACd,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,GAAG,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;aACpD;YACD,OAAO;gBACH,IAAI,MAAA;gBACJ,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK;gBACxB,SAAS,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,SAAS,GAAG,KAAK,GAAG,KAAK,GAAG,oBAAa;aACnE,CAAC;QACN,CAAC,CAAC,CAAC;QACH,OAAO,WAAI,CAAC,MAAM,CAAC,CAAC;IACxB,CAAC,CAAC,CACL,CAAC;AACN,CAAC;AAhCD,gCAgCC\",\"sourcesContent\":[\"import { from, Observable } from 'rxjs';\\nimport { concat, mergeMap } from 'rxjs/operators';\\nimport { EEG_FREQUENCY } from './../muse';\\nimport { EEGReading } from './muse-interfaces';\\n\\nexport interface EEGSample {\\n    index: number;\\n    timestamp: number; // milliseconds since epoch\\n    data: number[];\\n}\\n\\nexport function zipSamples(eegReadings: Observable<EEGReading>): Observable<EEGSample> {\\n    const buffer: EEGReading[] = [];\\n    let lastTimestamp: number | null = null;\\n    return eegReadings.pipe(\\n        mergeMap<EEGReading, EEGReading[]>((reading) => {\\n            if (reading.timestamp !== lastTimestamp) {\\n                lastTimestamp = reading.timestamp;\\n                if (buffer.length) {\\n                    const result = from([[...buffer]]);\\n                    buffer.splice(0, buffer.length, reading);\\n                    return result;\\n                }\\n            }\\n            buffer.push(reading);\\n            return from([]);\\n        }),\\n        concat(from([buffer])),\\n        mergeMap((readings: EEGReading[]) => {\\n            const result = readings[0].samples.map((x, index) => {\\n                const data = [NaN, NaN, NaN, NaN, NaN];\\n                for (const reading of readings) {\\n                    data[reading.electrode] = reading.samples[index];\\n                }\\n                return {\\n                    data,\\n                    index: readings[0].index,\\n                    timestamp: readings[0].timestamp + index * 1000. / EEG_FREQUENCY,\\n                };\\n            });\\n            return from(result);\\n        }),\\n    );\\n}\\n\"]}",
headerContent: undefined,
mtime: 1578214476000
};